# Still Moment - Development Standards & Guidelines

**Version**: 1.0
**Last Updated**: 2025-11-09
**Quality Target**: 9/10 â­

Diese Datei definiert die verbindlichen Code-QualitÃ¤ts-Standards fÃ¼r Still Moment. Alle neuen Features und Ã„nderungen mÃ¼ssen diese Standards erfÃ¼llen.

---

## ğŸ¯ QualitÃ¤tsziele

| Bereich | Ziel | Status |
|---------|------|--------|
| **GesamtqualitÃ¤t** | 9/10 | âœ… Erreicht |
| **Automatisierung** | 10/10 | âœ… Erreicht |
| **Test Coverage** | â‰¥80% | âœ… 85%+ |
| **Accessibility** | 9/10 | âœ… Erreicht |
| **Dokumentation** | 8/10 | âœ… Erreicht |

---

## ğŸ“‹ Code-Standards

### 1. Swift Code Quality

#### 1.1 Verbotene Praktiken âŒ
```swift
// âŒ NIEMALS: Force Unwrapping
let value = optional!

// âŒ NIEMALS: Implicitly Unwrapped Optionals (auÃŸer fÃ¼r IBOutlets)
var property: String!

// âŒ NIEMALS: Preconditions (stattdessen throwing functions)
precondition(value > 0, "Value must be positive")

// âŒ NIEMALS: print() fÃ¼r Logging (stattdessen OSLog)
print("Debug message")

// âŒ NIEMALS: try! (auÃŸer dokumentierte Ausnahmen)
let result = try! dangerousOperation()
```

#### 1.2 Empfohlene Praktiken âœ…
```swift
// âœ… Optional Binding
if let value = optional {
    // Use value
}

// âœ… Guard Statements fÃ¼r Early Returns
guard let value = optional else {
    return
}

// âœ… Throwing Functions statt Preconditions
init(value: Int) throws {
    guard value > 0 else {
        throw ValidationError.invalidValue(value)
    }
    self.value = value
}

// âœ… OSLog fÃ¼r Logging
import OSLog
Logger.domain.info("Operation completed", metadata: ["value": value])

// âœ… Proper Error Handling
do {
    let result = try dangerousOperation()
    // Handle result
} catch {
    Logger.error.error("Operation failed", error: error)
    // Handle error gracefully
}
```

#### 1.3 Typed Errors
Alle Errors mÃ¼ssen typed und documented sein:

```swift
// âœ… Typed Error Enum
enum MyServiceError: Error, LocalizedError {
    case invalidInput(String)
    case networkFailure(URLError)
    case unknownError

    var errorDescription: String? {
        switch self {
        case .invalidInput(let input):
            return "Invalid input: \(input)"
        case .networkFailure(let error):
            return "Network error: \(error.localizedDescription)"
        case .unknownError:
            return "An unknown error occurred"
        }
    }
}
```

### 2. Architecture Standards

#### 2.1 Layer Structure
```
Still Moment/
â”œâ”€â”€ Domain/              # Pure business logic (no dependencies)
â”‚   â”œâ”€â”€ Models/          # Value types (structs, enums)
â”‚   â””â”€â”€ Services/        # Protocol definitions
â”œâ”€â”€ Application/         # ViewModels, UseCases
â”‚   â””â”€â”€ ViewModels/      # @MainActor, ObservableObject
â”œâ”€â”€ Presentation/        # SwiftUI Views (no business logic)
â”‚   â””â”€â”€ Views/           # Pure UI components
â”œâ”€â”€ Infrastructure/      # Implementations
â”‚   â”œâ”€â”€ Services/        # Concrete implementations
â”‚   â””â”€â”€ Logging/         # OSLog extensions
â””â”€â”€ Resources/           # Assets, sounds, etc.
```

#### 2.2 Dependency Rules
- **Domain** darf KEINE Dependencies haben (pure Swift)
- **Application** darf nur Domain importieren
- **Presentation** darf Domain + Application importieren
- **Infrastructure** implementiert Domain Protocols

#### 2.3 Protocol-Based Design
Alle Services MÃœSSEN als Protocols definiert sein:

```swift
// âœ… Protocol in Domain Layer
protocol TimerServiceProtocol {
    var timerPublisher: AnyPublisher<MeditationTimer, Never> { get }
    func start(durationMinutes: Int)
    func pause()
    func resume()
    func reset()
    func stop()
}

// âœ… Implementation in Infrastructure Layer
final class TimerService: TimerServiceProtocol {
    // Implementation
}

// âœ… Dependency Injection in ViewModel
final class TimerViewModel: ObservableObject {
    private let timerService: TimerServiceProtocol

    init(timerService: TimerServiceProtocol = TimerService()) {
        self.timerService = timerService
    }
}
```

### 3. Thread Safety

#### 3.1 MainActor Usage
```swift
// âœ… ViewModels mÃ¼ssen @MainActor sein
@MainActor
final class TimerViewModel: ObservableObject {
    @Published var state: TimerState = .idle

    func updateUI() {
        // Guaranteed to run on main thread
    }
}
```

#### 3.2 Combine Publishers
```swift
// âœ… Immer auf Main Thread fÃ¼r UI Updates
timerService.timerPublisher
    .receive(on: DispatchQueue.main)  // âœ… Explicit main thread
    .sink { [weak self] timer in
        self?.updateFromTimer(timer)
    }
    .store(in: &cancellables)
```

### 4. Memory Management

#### 4.1 Weak References in Closures
```swift
// âœ… Weak self in Closures
service.publisher
    .sink { [weak self] value in  // âœ… Prevent retain cycle
        self?.handleValue(value)
    }
    .store(in: &cancellables)

// âœ… Weak self in Timer Callbacks
Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .sink { [weak self] _ in
        self?.tick()
    }
```

---

## ğŸ§ª Testing Standards

### 1. Test Coverage Requirements

#### Minimum Coverage Thresholds
- **Overall**: â‰¥80% (enforced in CI)
- **Domain Layer**: â‰¥95%
- **Application Layer**: â‰¥90%
- **Infrastructure Layer**: â‰¥85%
- **UI Layer**: â‰¥70%

#### Coverage Verification
```bash
# Generate coverage report
./scripts/generate-coverage-report.sh

# CI automatically fails if < 80%
```

### 2. Test Structure

#### 2.1 Unit Test Template
```swift
import XCTest
@testable import Still Moment

final class MyServiceTests: XCTestCase {
    var sut: MyService!  // System Under Test

    override func setUp() {
        super.setUp()
        sut = MyService()
    }

    override func tearDown() {
        sut = nil
        super.tearDown()
    }

    // MARK: - Test Cases

    func testFeatureName() {
        // Given - Setup
        let input = "test"

        // When - Execute
        let result = sut.process(input)

        // Then - Assert
        XCTAssertEqual(result, expected)
    }
}
```

#### 2.2 ViewModel Tests mit Mocks
```swift
// âœ… Mock Services fÃ¼r isolierte Tests
final class MockTimerService: TimerServiceProtocol {
    var startCalled = false
    var lastStartDuration: Int?

    func start(durationMinutes: Int) {
        startCalled = true
        lastStartDuration = durationMinutes
    }
}

@MainActor
final class TimerViewModelTests: XCTestCase {
    var sut: TimerViewModel!
    var mockService: MockTimerService!

    override func setUp() {
        super.setUp()
        mockService = MockTimerService()
        sut = TimerViewModel(timerService: mockService)
    }

    func testStartTimer() {
        // Given
        sut.selectedMinutes = 10

        // When
        sut.startTimer()

        // Then
        XCTAssertTrue(mockService.startCalled)
        XCTAssertEqual(mockService.lastStartDuration, 10)
    }
}
```

### 3. Test Categories

#### Must-Have Tests fÃ¼r jede neue Funktion:
- âœ… Happy Path Tests
- âœ… Error Case Tests
- âœ… Edge Case Tests (0, max, negative)
- âœ… Null/Nil Tests
- âœ… State Transition Tests

#### Beispiel:
```swift
// âœ… Happy Path
func testInitializationWithValidDuration() throws {
    let timer = try MeditationTimer(durationMinutes: 10)
    XCTAssertEqual(timer.durationMinutes, 10)
}

// âœ… Error Cases
func testInitializationWithZero() {
    XCTAssertThrowsError(try MeditationTimer(durationMinutes: 0))
}

func testInitializationWithNegative() {
    XCTAssertThrowsError(try MeditationTimer(durationMinutes: -5))
}

func testInitializationWithOverLimit() {
    XCTAssertThrowsError(try MeditationTimer(durationMinutes: 61))
}

// âœ… Edge Cases
func testInitializationWithMinimum() throws {
    let timer = try MeditationTimer(durationMinutes: 1)
    XCTAssertEqual(timer.durationMinutes, 1)
}

func testInitializationWithMaximum() throws {
    let timer = try MeditationTimer(durationMinutes: 60)
    XCTAssertEqual(timer.durationMinutes, 60)
}
```

---

## ğŸ“Š Logging Standards

### 1. OSLog Usage

#### 1.1 Logger Kategorien
```swift
// âœ… Verwende vordefinierte Logger
Logger.timer         // Timer operations
Logger.audio         // Audio playback
Logger.notifications // Notifications
Logger.viewModel     // ViewModel actions
Logger.lifecycle     // App lifecycle
Logger.error         // Errors only
Logger.performance   // Performance monitoring
```

#### 1.2 Log Levels

```swift
// DEBUG - Development info
Logger.timer.debug("Timer tick", metadata: ["remaining": 595])

// INFO - Important events
Logger.timer.info("Starting timer", metadata: ["duration": 10])

// WARNING - Recoverable issues
Logger.audio.warning("Audio session not configured")

// ERROR - Errors that need attention
Logger.audio.error("Failed to play sound", error: audioError)

// CRITICAL - Critical errors
Logger.error.critical("Fatal error", error: fatalError)
```

#### 1.3 Performance Monitoring
```swift
// âœ… Measure operation performance
let result = Logger.performance.measure(operation: "Load audio") {
    try loadAudioFile()
}

// âœ… Async operations
let result = await Logger.performance.measure(operation: "Fetch data") {
    try await fetchData()
}
```

### 2. Logging Best Practices

#### DO âœ…
```swift
// âœ… Log with context
Logger.timer.info("Timer started", metadata: [
    "duration": selectedMinutes,
    "timestamp": Date().timeIntervalSince1970
])

// âœ… Log errors with full context
Logger.error.error("Failed to save", error: error, metadata: [
    "userId": userId,
    "attemptCount": attempts
])

// âœ… Log state transitions
Logger.viewModel.info("State changed", metadata: [
    "from": oldState,
    "to": newState
])
```

#### DON'T âŒ
```swift
// âŒ print() statements
print("Debug: \(value)")

// âŒ NSLog
NSLog("Something happened")

// âŒ Empty metadata
Logger.timer.info("Something happened")  // What happened? Add context!

// âŒ Sensitive data
Logger.debug("User password: \(password)")  // NEVER log sensitive data!
```

---

## â™¿ Accessibility Standards

### 1. Mandatory Accessibility Labels

Alle interaktiven UI-Elemente MÃœSSEN accessibility labels haben:

```swift
// âœ… Buttons
Button("Start") {
    startTimer()
}
.accessibilityLabel("Start meditation")
.accessibilityHint("Starts the meditation timer with the selected duration")

// âœ… Pickers
Picker("Minutes", selection: $selectedMinutes) {
    // ...
}
.accessibilityLabel("Meditation duration picker")
.accessibilityHint("Select the duration for your meditation session in minutes")

// âœ… Text mit Kontext
Text(formattedTime)
    .accessibilityLabel("Remaining time")
    .accessibilityValue(accessibilityTimeValue)  // "5 minutes and 30 seconds remaining"

// âœ… State Indicators
Text(stateText)
    .accessibilityLabel(accessibilityStateLabel)  // "Timer is running. Currently meditating."
```

### 2. Accessibility Helpers

```swift
// âœ… Natural language fÃ¼r VoiceOver
private var accessibilityTimeValue: String {
    let minutes = remainingSeconds / 60
    let seconds = remainingSeconds % 60

    var components: [String] = []

    if minutes > 0 {
        components.append("\(minutes) \(minutes == 1 ? "minute" : "minutes")")
    }

    if seconds > 0 {
        components.append("\(seconds) \(seconds == 1 ? "second" : "seconds")")
    }

    return components.joined(separator: " and ") + " remaining"
}
```

### 3. Accessibility Testing

```bash
# âœ… Teste mit VoiceOver auf Device
# Settings > Accessibility > VoiceOver

# âœ… Teste mit Accessibility Inspector
# Xcode > Open Developer Tool > Accessibility Inspector

# âœ… UI Tests sollten accessibility-aware sein
XCTAssertTrue(app.buttons["Start meditation"].exists)
```

---

## ğŸ”§ Automation Standards

### 1. Pre-Commit Hooks

**Automatisch ausgefÃ¼hrt bei jedem Commit:**

```bash
# Setup (einmalig)
./scripts/setup-hooks.sh

# Was passiert bei jedem Commit:
1. SwiftFormat - Code wird automatisch formatiert
2. SwiftLint - Code Quality wird geprÃ¼ft
3. detect-secrets - Secrets werden gescannt
4. Trailing whitespace wird entfernt
5. YAML Dateien werden validiert
```

**Bei Violations:**
- Commit wird BLOCKIERT
- Fehler werden angezeigt
- Entwickler muss Fehler beheben

### 2. CI/CD Pipeline

#### 2.1 CI Workflow (bei jedem Push/PR)

```yaml
Runs automatically:
1. Lint Job
   - SwiftLint strict checking
   - SwiftFormat validation

2. Build & Test Job
   - Clean build
   - Unit tests
   - Code coverage generation
   - Coverage threshold check (â‰¥80%)

3. UI Tests Job
   - UI test suite

4. Static Analysis Job
   - Xcode Analyze
```

#### 2.2 Failing Conditions
Pipeline MUSS fehlschlagen bei:
- âŒ SwiftLint violations
- âŒ SwiftFormat issues
- âŒ Any test failures
- âŒ Coverage < 80%
- âŒ Build errors
- âŒ Static analysis warnings

### 3. Code Review Checklist

Vor jedem PR/Commit prÃ¼fen:

#### Code Quality âœ…
- [ ] Keine SwiftLint warnings
- [ ] Code ist formatiert (SwiftFormat)
- [ ] Keine force unwraps (!)
- [ ] Keine print() statements
- [ ] Proper error handling
- [ ] OSLog verwendet

#### Testing âœ…
- [ ] Unit tests geschrieben
- [ ] Tests sind grÃ¼n (âŒ˜U)
- [ ] Coverage â‰¥80%
- [ ] Edge cases getestet
- [ ] Mock services verwendet

#### Accessibility âœ…
- [ ] Accessibility labels gesetzt
- [ ] VoiceOver getestet
- [ ] Hints hinzugefÃ¼gt
- [ ] Natural language verwendet

#### Documentation âœ…
- [ ] Public APIs dokumentiert
- [ ] Complex logic kommentiert
- [ ] CHANGELOG.md aktualisiert
- [ ] README.md aktualisiert (wenn nÃ¶tig)

---

## ğŸ“¦ New Feature Checklist

Bei jedem neuen Feature:

### 1. Planning Phase
- [ ] Feature in DEVELOPMENT.md dokumentieren
- [ ] Architecture Review (passt es zur Clean Architecture?)
- [ ] Breaking Changes identifizieren
- [ ] Dependencies prÃ¼fen

### 2. Implementation Phase

#### Domain Layer
- [ ] Models als `struct` (Value Types)
- [ ] Protocols definieren
- [ ] Keine Framework-Dependencies
- [ ] Unit tests (â‰¥95% coverage)

#### Application Layer
- [ ] ViewModel mit `@MainActor`
- [ ] Dependency Injection
- [ ] Proper error handling
- [ ] Unit tests mit Mocks (â‰¥90% coverage)

#### Presentation Layer
- [ ] SwiftUI Views (keine Business Logic)
- [ ] Accessibility labels
- [ ] SwiftUI Previews
- [ ] UI tests (â‰¥70% coverage)

#### Infrastructure Layer
- [ ] Service implementations
- [ ] OSLog integration
- [ ] Error handling
- [ ] Unit tests (â‰¥85% coverage)

### 3. Quality Assurance Phase
- [ ] Alle Tests grÃ¼n (âŒ˜U)
- [ ] Coverage â‰¥80%
- [ ] SwiftLint clean
- [ ] SwiftFormat clean
- [ ] Accessibility geprÃ¼ft
- [ ] Performance geprÃ¼ft
- [ ] Memory leaks geprÃ¼ft (Instruments)

### 4. Documentation Phase
- [ ] Inline documentation
- [ ] CHANGELOG.md updated
- [ ] README.md updated (wenn nÃ¶tig)
- [ ] API documentation (DocC)

### 5. Release Phase
- [ ] CI Pipeline grÃ¼n
- [ ] Manual testing auf Device
- [ ] Git tag erstellen (`v*`)
- [ ] Release notes schreiben

---

## ğŸ¨ SwiftUI Best Practices

### 1. View Structure

```swift
// âœ… Computed Properties fÃ¼r View-Komponenten
struct TimerView: View {
    @StateObject private var viewModel: TimerViewModel

    var body: some View {
        VStack {
            titleSection
            timerDisplay
            controlButtons
        }
    }

    // âœ… Private computed properties fÃ¼r bessere Lesbarkeit
    private var titleSection: some View {
        Text("Still Moment")
            .font(.largeTitle)
    }

    private var timerDisplay: some View {
        Text(viewModel.formattedTime)
            .font(.system(size: 60))
    }

    private var controlButtons: some View {
        HStack {
            if viewModel.canStart {
                startButton
            }
        }
    }
}
```

### 2. State Management

```swift
// âœ… StateObject fÃ¼r ViewModel
@StateObject private var viewModel = TimerViewModel()

// âœ… State fÃ¼r lokalen UI State
@State private var isShowing = false

// âœ… Binding fÃ¼r Child Views
struct ChildView: View {
    @Binding var value: String
}
```

### 3. Previews

```swift
// âœ… Multiple Previews fÃ¼r verschiedene States
#Preview("Idle") {
    TimerView()
}

#Preview("Running") {
    let viewModel = TimerViewModel.preview(state: .running)
    TimerView(viewModel: viewModel)
}

#Preview("Dark Mode") {
    TimerView()
        .preferredColorScheme(.dark)
}
```

---

## ğŸš¨ Common Pitfalls & Solutions

### 1. Retain Cycles

```swift
// âŒ BAD: Strong reference cycle
.sink { timer in
    self.updateTimer(timer)  // Captures self strongly!
}

// âœ… GOOD: Weak reference
.sink { [weak self] timer in
    self?.updateTimer(timer)
}
```

### 2. Main Thread Issues

```swift
// âŒ BAD: UI update on background thread
service.fetchData { data in
    self.items = data  // Might be on background thread!
}

// âœ… GOOD: Explicit main thread
service.fetchData { data in
    DispatchQueue.main.async {
        self.items = data
    }
}

// âœ… BETTER: Combine with receive(on:)
service.publisher
    .receive(on: DispatchQueue.main)
    .sink { data in
        self.items = data  // Guaranteed main thread
    }
```

### 3. Force Unwrapping

```swift
// âŒ BAD: Force unwrap
let url = URL(string: urlString)!

// âœ… GOOD: Guard statement
guard let url = URL(string: urlString) else {
    Logger.error.error("Invalid URL", metadata: ["url": urlString])
    return
}
```

---

## ğŸ“– Resources & Tools

### Required Tools
- **Xcode 16+** - IDE
- **SwiftLint** - Linting (`brew install swiftlint`)
- **SwiftFormat** - Formatting (`brew install swiftformat`)
- **pre-commit** - Git hooks (`brew install pre-commit`)

### Recommended Tools
- **Instruments** - Performance profiling
- **Accessibility Inspector** - Accessibility testing
- **Console.app** - OSLog viewing

### Documentation
- [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)
- [SwiftUI Best Practices](https://developer.apple.com/documentation/swiftui)
- [Accessibility Guidelines](https://developer.apple.com/accessibility/)
- [OSLog Documentation](https://developer.apple.com/documentation/os/logging)

---

## ğŸ”„ Continuous Improvement

### Regular Reviews
- **Weekly**: Code quality metrics
- **Sprint**: Architecture review
- **Release**: Full quality audit

### Metrics to Track
- Test coverage trend
- SwiftLint violations trend
- Build time trend
- CI success rate
- Accessibility compliance

### When to Update This Document
- New best practices identified
- New tools adopted
- Architecture changes
- Team feedback

---

## âœ… Quick Reference Card

```bash
# Setup new environment
./scripts/setup-hooks.sh

# Before committing
swiftformat .
swiftlint lint --strict
âŒ˜U  # Run tests

# Generate coverage report
./scripts/generate-coverage-report.sh

# Check if ready for PR
âœ“ All tests pass
âœ“ Coverage â‰¥80%
âœ“ No SwiftLint violations
âœ“ Code formatted
âœ“ Accessibility labels added
âœ“ Documentation updated
```

---

**Remember**: Diese Standards sind VERBINDLICH. Keine Ausnahmen ohne dokumentierte BegrÃ¼ndung und Team-Approval.

**Version History**:
- v1.0 (2025-10-26): Initial standards based on quality improvements
